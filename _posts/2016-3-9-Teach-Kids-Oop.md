---
layout: post
title: Teach kids in (hi-)school OOP (but for the love of code don't teach them Javascript)
---

Before we go into further details, I have one crucial request to make. Please, every time you see "javascript" in this post, read it as *yaverrscript". You know, like with an imitation of an Australian accent (unless, of course, you're Australian, in which case you've won the world). This is essential in order to properly gasp the picture I'm painting here.

I live in Romania, however what I'm about to say somewhat applies to pretty much every country that's able to read this on its original source.

Teach kids OOP. It's about time already!

IT has become such an insanely huge part of our lives nowadays that it's just impossible to ignore it. We don't live in a world where we can just take things for granted. Technology has become so complexe and agressively intrusive that we can no longer just see it as a mere "perk" created by us, geniuses, that's meant to ease our lives and thus seriously bump our slacking levels.

The fact that programming is taught in some schools and high-schools is laudable. It's a shame that … you know … what most of them are teaching is procedural, 30-year old technologies and techniques. "Borland C much, 12yo!?" - it's not enough to be "laudable", it has to be "done well", "relevant" and "well-thought of and taught". We have to think way higher than that.

The most argument I come across in conversations about why we teach procedural programming to children is "well, it's the basics of programming, the very beginnings! You have to start from the 'beginning' when you learn something, right?" - wrong! If we've taught everything from the 'very beginnings' and put every new kid through the same primitive path of knowledge discovery that their parents and grand-parents and grand-grand-parents have been through, we haven't accomplished anything.

Some people see learning a specific domain as a straight line - "I start from somewhere, I go through steps A, B, C, and by the time I've got to checkpoint D, I can assume I'm pretty much halfway." That is wrong. There is no "beginning of knowledge", not one that we as humans can particularly imagine. Knowledge is more of a graph, with interdependences, relationships, between each node. This node depends on this node, and this other node depends on it. It's sort of like a web, a puzzle, if you may. Of course, it's ideal to start with perhaps a corner piece, or some piece that makes sense to us by itself, from which we can extend our knowledge puzzle.

So why OOP? Why not any other programming paradigm?
Because it feels "natural" . It's the simplest to understand and it's the one programming paradigm that's modelled by the way we think in real life. If you know OOP well, you can understand about any model somebody throws at you, because not only is it a solid programming paradigm, but it also greatly improves your learning capabilities.

Let me give you one simple example of how OOP can seriously amplify the extension of your knowledge graph. I'll use an imaginary example so that none of you have any prior knowledge about the topic.

* Start by thinking of emptiness. Void. Nothing exists in your imaginary universe. It's just a blank, unfilled writing board.

	
* Draw a circle in the middle of your space.



Woops. I've already broken my promise. I've lied to you about using imaginary notions, because I've asked you to imagine "emptiness" and draw a "circle". So even though you've had the feeling that you're "starting from scratch" with your knowledge base, you've instead hooked the model I was describing to some other notions you already knew, but you "abstracted them out" and only focused on what was relevant to you at that time, specifically understanding the model I was describing. This conceptual gimmick of "abstraction" is one of the pillars of OOP and is probably the most helpful, as it gives you that feeling of linearity. We as humans like linearity. It's how we've developed our way of thinking. No matter how much we try to base our way of thought on something like, say, logarithms, we just can't. Because we like thinking linearly. It feels so comfortable, right?

There's one question to be raised, though. How could you possibly abstract out the notion of a circle if you didn't even know what a circle was? I've told you that "emptiness" HAS a "circle", but where have I defined these two notions? That's where the "natural beauty" of OOP comes in. OOP is mostly based on models we observe in nature, models that are very familiar to us. If I point at a tree on the street and ask you to describe it to me, you will do so by telling me its characteristics, its PROPERTIES. Note that each such property is a standalone notion on its own, a notion that, again, a tree HAS.

So apparently I've lied to you a second time, right? The "simple example" I was telling you about isn't really all that simple, is it? That's another strong point. You can start out with no piece of the puzzle, from anywhere, and gradually complete it by adding pieces in any direction, perhaps more on one direction that you're particularly interested in , but fewer pieces in some other direction you have no interest of focusing on.

So now that we've been through this tangled hell of overthinking OOP, what do our kids have to do with it!? Well if they know OOP, they can :
	
* learn any model, simple or complex, by associating it with practical notions found in nature
	
* start out simple but go deeper on any particular notion branch on the knowledge graph if needed
	
* create interdependence relationships between the models in nature, find similarities and differences and better recognize patterns

Would you agree with me that these are probably the best 3 cognitive qualities someone needs to have in order to easily learn anything and everything there is to learn? Is there another you would add on the list? Please let me know in the comments below.

We've so far talked and talked about how OOP is the savior of mankind and how it could, in glorious theory, breed our brains. But what of the ACTUAL PRACTICAL APPLICATIONS of OOP? I've went through the trouble of explaining its general benefits because, obviously, even if we were to teach OOP in ALL the schools, not every kid would grow to become a programmer, but would have at least developed a proper way of learning anything he wants. But what of those who do become programmers when they're older? Is OOP the best programming paradigm of them all? Do we even need programmers to do pure procedural programming anymore?

At the time of writing this, we do. But few, and only to maintain old, outdated systems. But the majority of the world's systems nowadays are OOP driven. You don't need a programmer who knows all of the low-level C / Assembly stuff in order to do high-level software development. I have met many people who, even though could not give me a proper explanation of what a pointer was, were bloody good software developers. And that's, again, because of abstraction. You don't need to know dynamic memory allocation to do web development, you don't need pointers to do mobile apps etc. If you will ever need to, you can then just go study and understand those models at that specific time, not necessarily start out with them. Let hipsters be hipsters and geeks be geeks, the world needs both, so don't try to evangelize them.

There is a huge demand for developers on the job market right now, a huge amount of students attending programming-related courses, and frankly none of them are compatible because they're not learning technologies relevant for said jobs at said courses. If you catch them early with OOP, it will be much easier for them to learn whatever technologies you throw at them.

Teach kids OOP! It's about time already!

P.S. : there is one more thing I've misled you about in this post. See if you can find the right pronunciation for it.
